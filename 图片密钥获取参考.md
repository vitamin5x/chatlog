好的，给你参考一下另外一个程序获取密钥的代码，你参考一下，针对v4 版本，image有两个密钥，一个是AES,一个是XOR：

async autoGetImageKey(
  manualDir?: string,
  onProgress?: (message: string) => void
): Promise<ImageKeyResult> {
  if (!this.ensureWin32()) return { success: false, error: '仅支持 Windows' }
  if (!this.ensureLoaded()) return { success: false, error: 'wx_key.dll 未加载' }
  if (!this.ensureKernel32()) return { success: false, error: '初始化系统 API 失败' }

  onProgress?.('正在定位微信账号目录...')
  const accountDir = this.resolveAccountDir(manualDir)
  if (!accountDir) return { success: false, error: '未找到微信账号目录' }

  onProgress?.('正在收集模板文件...')
  const templateFiles = this.findTemplateDatFiles(accountDir)
  if (!templateFiles.length) return { success: false, error: '未找到模板文件' }

  onProgress?.('正在计算 XOR 密钥...')
  const xorKey = this.getXorKey(templateFiles)
  if (xorKey == null) return { success: false, error: '无法计算 XOR 密钥' }

  onProgress?.('正在读取加密模板数据...')
  const ciphertext = this.getCiphertextFromTemplate(templateFiles)
  if (!ciphertext) return { success: false, error: '无法读取加密模板数据' }

  const pid = await this.findWeChatPid()
  if (!pid) return { success: false, error: '未检测到微信进程' }

  onProgress?.('正在扫描内存获取 AES 密钥...')
  const aesKey = await this.getAesKeyFromMemory(pid, ciphertext)
  if (!aesKey) {
    return {
      success: false,
      error: '未能从内存中获取 AES 密钥，请打开朋友圈图片后重试'
    }
  }

  return { success: true, xorKey, aesKey: aesKey.slice(0, 16) }
}

辅助方法：resolveAccountDir - 定位微信账号目录
private resolveAccountDir(manualDir?: string): string | null {
  if (manualDir) {
    const resolved = this.resolveAccountDirFromPath(manualDir)
    if (resolved) return resolved
  }

  const userProfile = process.env.USERPROFILE
  if (!userProfile) return null
  const roots = [
    join(userProfile, 'Documents', 'xwechat_files'),
    join(userProfile, 'Documents', 'WeChat Files')
  ]
  for (const root of roots) {
    if (!existsSync(root)) continue
    const candidates = this.listAccountDirs(root)
    if (candidates.length) return candidates[0]
  }
  return null
}
findTemplateDatFiles - 查找模板图片文件
private findTemplateDatFiles(rootDir: string): string[] {
  const files: string[] = []
  const stack = [rootDir]
  const maxFiles = 32
  while (stack.length && files.length < maxFiles) {
    const dir = stack.pop() as string
    let entries: string[]
    try {
      entries = readdirSync(dir)
    } catch {
      continue
    }
    for (const entry of entries) {
      const fullPath = join(dir, entry)
      let stats: any
      try {
        stats = statSync(fullPath)
      } catch {
        continue
      }
      if (stats.isDirectory()) {
        stack.push(fullPath)
      } else if (stats.isFile() && entry.endsWith('.dat') && (entry.startsWith('_t') || entry.endsWith('_t.dat'))) {
        files.push(fullPath)
      }
    }
  }
  return files
}
findWeChatPid - 查找微信进程ID
private async findWeChatPid(): Promise<number | null> {
  const names = ['Weixin.exe', 'WeChat.exe']
  for (const name of names) {
    const pid = await this.findPidByImageName(name)
    if (pid) return pid
  }

  const fallbackPid = await this.waitForWeChatWindow(5000)
  return fallbackPid ?? null
}
密钥计算方法
getXorKey - 计算XOR密钥
private getXorKey(templateFiles: string[]): number | null {
  const counts = new Map<number, number>()
  const tailSignatures = [
    Buffer.from([0xFF, 0xD9]),
    Buffer.from([0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82])
  ]
  for (const file of templateFiles) {
    try {
      const bytes = readFileSync(file)
      for (const signature of tailSignatures) {
        if (bytes.length < signature.length) continue
        const tail = bytes.subarray(bytes.length - signature.length)
        const xorKey = tail[0] ^ signature[0]
        let valid = true
        for (let i = 1; i < signature.length; i++) {
          if ((tail[i] ^ xorKey) !== signature[i]) {
            valid = false
            break
          }
        }
        if (valid) {
          counts.set(xorKey, (counts.get(xorKey) ?? 0) + 1)
        }
      }
    } catch { }
  }
  if (!counts.size) return null
  let bestKey: number | null = null
  let bestCount = 0
  for (const [key, count] of counts) {
    if (count > bestCount) {
      bestCount = count
      bestKey = key
    }
  }
  return bestKey
}
getCiphertextFromTemplate - 获取加密模板数据
private getCiphertextFromTemplate(templateFiles: string[]): Buffer | null {
  for (const file of templateFiles) {
    try {
      const bytes = readFileSync(file)
      if (bytes.length < 0x1f) continue
      if (
        bytes[0] === 0x07 &&
        bytes[1] === 0x08 &&
        bytes[2] === 0x56 &&
        bytes[3] === 0x32 &&
        bytes[4] === 0x08 &&
        bytes[5] === 0x07
      ) {
        return bytes.subarray(0x0f, 0x1f)
      }
    } catch { }
  }
  return null
}
内存扫描方法 getAesKeyFromMemory - 从微信进程内存获取AES密钥
private async getAesKeyFromMemory(pid: number, ciphertext: Buffer): Promise<string | null> {
  if (!this.ensureKernel32()) return null
  const hProcess = this.OpenProcess(this.PROCESS_ALL_ACCESS, false, pid)
  if (!hProcess) return null

  try {
    const regions = this.getMemoryRegions(hProcess)
    const chunkSize = 4 * 1024 * 1024
    const overlap = 65
    for (const [baseAddress, regionSize] of regions) {
      if (regionSize > 100 * 1024 * 1024) continue
      let offset = 0
      let trailing: Buffer | null = null
      while (offset < regionSize) {
        const remaining = regionSize - offset
        const currentChunkSize = remaining > chunkSize ? chunkSize : remaining
        const chunk = this.readProcessMemory(hProcess, baseAddress + offset, currentChunkSize)
        if (!chunk || !chunk.length) {
          offset += currentChunkSize
          trailing = null
          continue
        }

        let dataToScan: Buffer
        if (trailing && trailing.length) {
          dataToScan = Buffer.concat([trailing, chunk])
        } else {
          dataToScan = chunk
        }

        for (let i = 0; i < dataToScan.length - 34; i++) {
          if (this.isAlphaNumAscii(dataToScan[i])) continue
          let valid = true
          for (let j = 1; j <= 32; j++) {
            if (!this.isAlphaNumAscii(dataToScan[i + j])) {
              valid = false
              break
            }
          }
          if (valid && this.isAlphaNumAscii(dataToScan[i + 33])) {
            valid = false
          }
          if (valid) {
            const keyBytes = dataToScan.subarray(i + 1, i + 33)
            if (this.verifyKey(ciphertext, keyBytes)) {
              return keyBytes.toString('ascii')
            }
          }
        }

        for (let i = 0; i < dataToScan.length - 65; i++) {
          if (!this.isUtf16AsciiKey(dataToScan, i)) continue
          const keyBytes = Buffer.alloc(32)
          for (let j = 0; j < 32; j++) {
            keyBytes[j] = dataToScan[i + j * 2]
          }
          if (this.verifyKey(ciphertext, keyBytes)) {
            return keyBytes.toString('ascii')
          }
        }

        const start = dataToScan.length - overlap
        trailing = dataToScan.subarray(start < 0 ? 0 : start)
        offset += currentChunkSize
      }
    }
    return null
  } finally {
    try {
      this.CloseHandle(hProcess)
    } catch { }
  }
}
getMemoryRegions - 获取进程内存区域
private getMemoryRegions(hProcess: any): Array<[number, number]> {
  const regions: Array<[number, number]> = []
  const MEM_COMMIT = 0x1000
  const MEM_PRIVATE = 0x20000
  const MEM_MAPPED = 0x40000
  const MEM_IMAGE = 0x1000000
  const PAGE_NOACCESS = 0x01
  const PAGE_GUARD = 0x100

  let address = 0
  const maxAddress = 0x7fffffffffff
  while (address >= 0 && address < maxAddress) {
    const info: any = {}
    const result = this.VirtualQueryEx(hProcess, address, info, this.koffi.sizeof(this.MEMORY_BASIC_INFORMATION))
    if (!result) break

    const state = info.State
    const protect = info.Protect
    const type = info.Type
    const regionSize = Number(info.RegionSize)
    if (state === MEM_COMMIT && (protect & PAGE_NOACCESS) === 0 && (protect & PAGE_GUARD) === 0) {
      if (type === MEM_PRIVATE || type === MEM_MAPPED || type === MEM_IMAGE) {
        regions.push([Number(info.BaseAddress), regionSize])
      }
    }

    const nextAddress = address + regionSize
    if (nextAddress <= address) break
    address = nextAddress
  }
  return regions
}
readProcessMemory - 读取进程内存
private readProcessMemory(hProcess: any, address: number, size: number): Buffer | null {
  const buffer = Buffer.alloc(size)
  const bytesRead = [0]
  const ok = this.ReadProcessMemory(hProcess, address, buffer, size, bytesRead)
  if (!ok || bytesRead[0] === 0) return null
  return buffer.subarray(0, bytesRead[0])
}

private isAlphaNumAscii(byte: number): boolean {
  return (byte >= 0x61 && byte <= 0x7a) || (byte >= 0x41 && byte <= 0x5a) || (byte >= 0x30 && byte <= 0x39)
}

private isUtf16AsciiKey(buf: Buffer, start: number): boolean {
  if (start + 64 > buf.length) return false
  for (let j = 0; j < 32; j++) {
    const charByte = buf[start + j * 2]
    const nullByte = buf[start + j * 2 + 1]
    if (nullByte !== 0x00 || !this.isAlphaNumAscii(charByte)) {
      return false
    }
  }
  return true
}

verifyKey - 验证密钥是否正确
private verifyKey(ciphertext: Buffer, keyBytes: Buffer): boolean {
  try {
    const key = keyBytes.subarray(0, 16)
    const decipher = crypto.createDecipheriv('aes-128-ecb', key, null)
    decipher.setAutoPadding(false)
    const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()])
    const isJpeg = decrypted.length >= 3 && decrypted[0] === 0xff && decrypted[1] === 0xd8 && decrypted[2] === 0xff
    const isPng = decrypted.length >= 8 &&
      decrypted[0] === 0x89 &&
      decrypted[1] === 0x50 &&
      decrypted[2] === 0x4e &&
      decrypted[3] === 0x47 &&
      decrypted[4] === 0x0d &&
      decrypted[5] === 0x0a &&
      decrypted[6] === 0x1a &&
      decrypted[7] === 0x0a
    return isJpeg || isPng
  } catch {
    return false
  }
}

解密方法：
private decryptDatV4(inputPath: string, xorKey: number, aesKey: Buffer): Buffer {
  const bytes = readFileSync(inputPath)
  if (bytes.length < 0x0f) {
    throw new Error('文件太小，无法解析')
  }

  const header = bytes.subarray(0, 0x0f)
  const data = bytes.subarray(0x0f)
  const aesSize = this.bytesToInt32(header.subarray(6, 10))
  const xorSize = this.bytesToInt32(header.subarray(10, 14))

  // AES 数据需要对齐到 16 字节（PKCS7 填充）
  // 当 aesSize % 16 === 0 时，仍需要额外 16 字节的填充
  const remainder = ((aesSize % 16) + 16) % 16
  const alignedAesSize = aesSize + (16 - remainder)
  
  if (alignedAesSize > data.length) {
    throw new Error('文件格式异常：AES 数据长度超过文件实际长度')
  }

  const aesData = data.subarray(0, alignedAesSize)
  let unpadded: Buffer = Buffer.alloc(0)
  if (aesData.length > 0) {
    const decipher = crypto.createDecipheriv('aes-128-ecb', aesKey, null)
    decipher.setAutoPadding(false)
    const decrypted = Buffer.concat([decipher.update(aesData), decipher.final()])
    
    // 使用 PKCS7 填充移除
    unpadded = this.strictRemovePadding(decrypted)
  }

  const remaining = data.subarray(alignedAesSize)
  if (xorSize < 0 || xorSize > remaining.length) {
    throw new Error('文件格式异常：XOR 数据长度不合法')
  }

  let rawData = Buffer.alloc(0)
  let xoredData = Buffer.alloc(0)
  if (xorSize > 0) {
    const rawLength = remaining.length - xorSize
    if (rawLength < 0) {
      throw new Error('文件格式异常：原始数据长度小于XOR长度')
    }
    rawData = remaining.subarray(0, rawLength)
    const xorData = remaining.subarray(rawLength)
    xoredData = Buffer.alloc(xorData.length)
    for (let i = 0; i < xorData.length; i += 1) {
      xoredData[i] = xorData[i] ^ xorKey
    }
  } else {
    rawData = remaining
    xoredData = Buffer.alloc(0)
  }

  return Buffer.concat([unpadded, rawData, xoredData])
}

private bytesToInt32(bytes: Buffer): number {
  if (bytes.length !== 4) {
    throw new Error('需要4个字节')
  }
  return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24)
}

private strictRemovePadding(data: Buffer): Buffer {
  if (!data.length) {
    throw new Error('解密结果为空，填充非法')
  }
  const paddingLength = data[data.length - 1]
  if (paddingLength === 0 || paddingLength > 16 || paddingLength > data.length) {
    throw new Error('PKCS7 填充长度非法')
  }
  for (let i = data.length - paddingLength; i < data.length; i += 1) {
    if (data[i] !== paddingLength) {
      throw new Error('PKCS7 填充内容非法')
    }
  }
  return data.subarray(0, data.length - paddingLength)
}

asciiKey16(keyString: string): Buffer {
  if (keyString.length < 16) {
    throw new Error('AES密钥至少需要16个字符')
  }
  return Buffer.from(keyString, 'ascii').subarray(0, 16)
}